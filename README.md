# Виджет для банковских операций

## Обзор

Данный проект представляет собой виджет для упрощения банковских операций, разработанный на Python. Виджет предоставляет удобный интерфейс для выполнения различных задач, который на бэкенде будет готовить данные для отображения в новом виджете. Таких, как маскировка номеров банковских карт и счетов и сортировка списков словарей клиентов по датам и определённым значениям

## Установка

Для установки виджета выполните следующие шаги:

1. **Клонируйте репозиторий используя инструмент управления версиями `git`:**
    ```
    git clone github.com/cardinal3300/Tasks-Project-SkyPro cd <имя_вашего_проекта>
   ```
2. **Установите зависимости, используя менеджер пакетов `poetry`:**
    ```
   poetry install --no-root
   ```
## Использование

### Виджет предоставляет следующие модули и функции:

### 1. Модуль `masks.py` содержит функции:

### `get_mask_card_number(card_number)`

Пример использования:

Функция возвращает замаскированный номер банковской карты, в формате XXXX XX** **** XXXX, где X - цифры.

*   **Параметры:**

    *   `card_number: int или str`: Номер банковской карты.

*   **Возвращаемое значение:**

    *   (str): Замаскированный номер карты или сообщение об ошибке (если входные данные неверны).

*   **Пример:**

    ```python
    from your_module import get_mask_card_number # Замените your_module на имя вашего модуля
    card_number = 1234567890123456
    masked_card = get_mask_card_number(card_number)
    print(masked_card)
    >>> 1234 56** ** 3456

### `get_mask_account(check_number)`

Функция Маскирует номер банковского счета, отображая последние 4 цифры в формате **XXXX.

*   **Параметры:**

    *   `check_number: int или str`: Номер банковского номера или счета.

*   **Возвращаемое значение:**

    *   (str): Замаскированный номер счета или сообщение об ошибке (если входные данные неверны).

*   **Пример:**

    ```python
    from your_module import get_mask_account # Замените your_module на имя вашего модуля
    account_check_number = 73654108430135874305
    masked_check_number = get_mask_account(account_check_number)
    print(masked_check_number)
    >>> **4305

### 2. Модуль `widget.py` содержит функции:

### `mask_account_card(type_and_number)`

Функция маскирует номер карты или счета в зависимости от типа.

*   **Параметры:**

    *   `type_and_number: int или str`: Тип с номером карты или банковским счётом.

*   **Возвращаемое значение:**

    *   (str): Замаскированный тип с номером или замаскированный счет.

*   **Пример:**

    ```python
    from your_module import mask_account_card # Замените your_module на имя вашего модуля
    account_type_and_number = Platinum Visa 7000792289606361
    masked_account_type_number = mask_account_card(account_type_and_number)
    print(masked_account_type_number)
    >>> Visa Platinum 7000 79** **** 6361

### `get_date(data_card_number)`

Функция возвращает строку с датой в формате 'ДД.ММ.ГГГГ'.

*   **Параметры**

    *   `data_card_number: str`: Строка с датой.

*   **Возвращаемое значение**

    *   (str): строка с датой в формате "ДД.ММ.ГГГГ" ("11.03.2024")   

*   **Пример**

    ```Python
    from your_module import get_date # Замените your_module на имя вашего модуля
    account_data = 2024-03-11T02:26:18.671407
    new_account_data = get_date(account_data)
    print(new_account_data)
    >>> 11.03.2024

### 3. Модуль `processing.py` содержит функции:

### `filter_by_state(data, state="EXECUTED")`

Функция фильтрует список словарей, возвращая только те, у которых значение ключа 'state' соответствует заданному.

*   **Параметры:**

    *   `data: list[dict]`: Список словарей.
    
    *   `state: str, optional`: Значение ключа 'state' для фильтрации. По умолчанию 'EXECUTED'.

*   **Возвращаемое значение:**

    *   list[dict]: Отфильтрованный список словарей.

*   **Пример:**

    ```python
    from your_module import filter_by_state # Замените your_module на имя вашего модуля  
    data = [{'id': 1, 'state': 'EXECUTED'},
            {'id': 2, 'state': 'PENDING'},
            {'id': 3, 'state': 'EXECUTED'}]
    print(filter_by_state(state_operation, state="CANCELED"))
    >>> [{'id': 594226727, 'state': 'CANCELED', 'date': '2018-09-12T21:27:25.241689'},
         {'id': 615064591, 'state': 'CANCELED', 'date': '2018-10-14T21:33:41.9441'}]

### `sort_by_date(data, reverse=True)`

Функция сортирует список словарей по значению ключа 'date' (в формате YYYY-MM-DD) по умолчанию по убыванию.

*   **Параметры**

    *   `date: list[dict]`: Список словарей, каждый из которых должен содержать ключ 'date'.
    *   `reverse: bool, optional`: Флаг, указывающий порядок сортировки
(True - убывание, False - возрастание). По умолчанию `True`.

*   **Возвращение функции**

    *   list[dict]: Отсортированный список словарей.
    
*   **Пример**

    ```python
    from your_module import sort_by_date # Замените your_module на имя вашего модуля
    data = [{'id': 41428829, 'state': 'EXECUTED', 'date': '2019-07-03T18:35:29.512364'},
            {'id': 939719570, 'state': 'EXECUTED', 'date': '2018-06-30T02:08:58.425572'},
            {'id': 594226727, 'state': 'CANCELED', 'date': '2018-09-12T21:27:25.241689'},
            {'id': 615064591, 'state': 'CANCELED', 'date': '2018-10-14T08:21:33.419441'}]
    print(sort_by_date(state_operation, reverse=False))
    >>> [{'id': 939719570, 'state': 'EXECUTED', 'date': '2018-06-30T02:08:58.425572'},
         {'id': 594226727, 'state': 'CANCELED', 'date': '2018-09-12T21:27:25.241689'},
         {'id': 615064591, 'state': 'CANCELED', 'date': '2018-10-14T21:33:41.9441'},
         {'id': 41428829, 'state': 'EXECUTED', 'date': '2019-07-03T18:35:29.512364'}]

### 4. Модуль `generators.py` содержит функции:

### `filter_by_currency(transactions: List[Dict[str, Any]], currency: str)`

Функция возвращает генератор только по тем транзакциям, где валюта соответствует заданной.

*   **Параметры:**

    *   `transactions: list`: Список словарей с транзакциями.

    *   `currency: str`: Код валюты для фильтрации, например, "USD".

*   **Возвращаемое значение:**

    *   Generator[list]: Итератор с отфильтрованными транзакциями.

*   **Пример:**

    ```python
    from your_module import filter_by_currency # Замените your_module на имя вашего модуля
    usd_transactions = filter_by_currency(transactions, "USD")
    for _ in range(3):
    print(next(usd_transactions))
    >>> {'id': 939719570, 'state': 'EXECUTED', 'date': '2018-06-30T02:08:58.425572', 'operationAmount': {'amount': '9824.07', 'currency': {'name': 'USD', 'code': 'USD'}}, 'description': 'Перевод организации', 'from': 'Счет 75106830613657916952', 'to': 'Счет 11776614605963066702'}
        {'id': 142264268, 'state': 'EXECUTED', 'date': '2019-04-04T23:20:05.206878', 'operationAmount': {'amount': '79114.93', 'currency': {'name': 'USD', 'code': 'USD'}}, 'description': 'Перевод со счета на счет', 'from': 'Счет 19708645243227258542', 'to': 'Счет 75651667383060284188'}
        {'id': 895315941, 'state': 'EXECUTED', 'date': '2018-08-19T04:27:37.904916', 'operationAmount': {'amount': '56883.54', 'currency': {'name': 'USD', 'code': 'USD'}}, 'description': 'Перевод с карты на карту', 'from': 'Visa Classic 6831982476737658', 'to': 'Visa Platinum 8990922113665229'}
    

### `transaction_descriptions(transactions: List[Dict[str, Any]])`

Функция генерирует описания транзакций из списка словарей с транзакциями.

*   **Параметры:**

    *   `transactions: list`: Список словарей, представляющих транзакции.

*   **Возвращаемое значение:**

    *   Generator[str]: Итератор описаний транзакций.

*   **Пример:**

    ```python
    from your_module import transaction_descriptions # Замените your_module на имя вашего модуля
    descriptions = transaction_descriptions(transactions)
    for _ in range(5):
    print(next(descriptions))
    >>> Перевод организации
        Перевод со счета на счет
        Перевод со счета на счет
        Перевод с карты на карту
        Перевод организации
    
### `card_number_generator(start: int, end: int)`

Генератор, который создает номера банковских карт в формате XXXX XXXX XXXX XXXX в заданном диапазоне.

*   **Параметры:**

    *   `start: int`: Начальное значение диапазона (включительно).
    
    *   `stop: int`: Конечное значение диапазона (включительно).

*   **Возвращаемое значение:**

    *   Generator[str]: Итератор с номерами банковских карт в заданном диапазоне.

*   **Пример:**

    ```python
    from your_module import card_number_generator # Замените your_module на имя вашего модуля
    for card_number in card_number_generator(1, 5):
    print(card_number)
    >>> 0000 0000 0000 0001
        0000 0000 0000 0002
        0000 0000 0000 0003
        0000 0000 0000 0004
        0000 0000 0000 0005
    

### `format_card_number(start: int, end: int)`

Функция приведения числа к строке.

*   **Параметры:**

    *   `number: int`: любое число.

*   **Возвращаемое значение:**

    *   (str): полученная строка.

*   **Пример:**

    ```python
    print(format_card_number(1234567891011121))
    >>> 1234 5678 9101 1121

### 5. Модуль `decorators.py` содержит функцию и декоратор:

### `message_log`

Функция логирования записи в файл для декоратора `@log()`.

*   **Параметры:**

    *   `message: str, filename: Optional[str] = None`

### `log(filename="log.txt")`

Декоратор для логирования вызова функции.

**Как это работает:**

1.  *Внешняя функция log(filename=None):*
    *   Принимает опциональный аргумент filename, определяющий место сохранения логов.
    *   Возвращает внутреннюю функцию decorator.

2.  *Внутренняя функция decorator(func):*
    *   Принимает декорируемую функцию func в качестве аргумента.
    *   Использует @functools.wraps(func) для сохранения метаданных оригинальной функции (имя, docstring и т.д.).  Это важно, чтобы декоратор не "терял" информацию о декорируемой функции.
    *   Возвращает функцию wrapper.

3.  *Внутренняя функция wrapper(*args, **kwargs):*
    *   Это основная логика декоратора.  Она будет выполняться вместо оригинальной функции.
    *   *Логирование начала выполнения:*  Записывает время вызова, имя функции и переданные аргументы (args и kwargs) в лог (файл или консоль).
    *   *Выполнение функции:*  Вызывает оригинальную функцию func(*args, **kwargs) и обрабатывает возможные исключения.
    *   *Логирование успешного выполнения:*  Если функция выполнена успешно, записывает результат выполнения и время выполнения.
    *   *Логирование ошибок:* Если возникает исключение, записывает информацию об ошибке (тип, сообщение об ошибке, переданные аргументы) и *повторно вызывает исключение* (raise), чтобы оно не было "проглочено" декоратором и обработано вызывающей функцией.
    *   Возвращает результат выполнения функции (если она выполнена успешно).

**Примеры использования:**

*   **Пример 1: Логирование в консоль**

     ```python
    from typing import Any, Callable, Optional
    @log()
    def my_func(x, y):
        """Складывает два числа в консоль."""
        return x + y
    print(my_func(5, 3)
    >>> 8

*   **Пример 2: Логирование в файл "my_log.txt"**

    ```python
    from typing import Any, Callable, Optional
    @log(filename="my_log.txt")
    def my_func(x: int, y: int) -> int:
        """Складывает два числа в файл."""
        return X + Y
    my_func(5, 3)
    >>> добавляется файл log.txt с значением "8"

**Как это работает (пример с выводом в консоль):**

1.  Когда вызывается add(5, 3), на самом деле вызывается wrapper функция, обернутая декоратором log().
2.  wrapper записывает в консоль сообщение о начале вызова функции add с аргументами 5 и 3.
3.  wrapper вызывает оригинальную функцию add(5, 3), которая возвращает 8.
4.  wrapper записывает в консоль сообщение об успешном завершении add с результатом 8.
5.  wrapper возвращает 8.

**Важные моменты:**

*   *functools.wraps:*  Обязательно используй его, чтобы сохранить информацию о декорируемой функции (имя, docstring и т.д.). Без этого, если ты попробуешь узнать информацию о функции через help() или func.__name__, ты увидишь информацию о wrapper, а не об оригинальной функции.
*   *Обработка исключений:* Важно перехватывать исключения и логировать их, чтобы знать, когда что-то пошло не так.  raise повторно вызывает исключение, чтобы оно не было "проглочено" декоратором.
*   *Гибкость:*  Декоратор можно легко настроить, изменяя формат логов, добавляя больше информации (например, идентификатор пользователя, время создания лога и т.д.), или интегрируя его с более сложными системами логирования (например, logging модуля).  В текущей версии используется time.strftime для форматирования времени, но можно заменить на logging.Formatter для более гибкого форматирования.
*   *Необязательный filename:*  Позволяет использовать декоратор как для логирования в консоль, так и в файл.
*   **Аргументы *args и **kwargs:**  Декоратор корректно обрабатывает функции с любым количеством позиционных и именованных аргументов.
*   *Время выполнения:* Декоратор измеряет время выполнения функции, что может быть полезно для анализа производительности.

Этот код предоставляет готовую основу для логирования, которую можно легко адаптировать.

### 6. Модуль `utils.py` содержит функцию:

### `reading_json_file((file_path: str)`

Функция принимает на вход путь до JSON-файла и возвращает список словарей с данными о финансовых транзакциях.

*   **Параметры**

    *   `file_path: str`: Путь до файла .json (по умолчанию в этом проекте `'../data/operations.json'`).

*   **Возвращаемое значение**

    *   `list[dict]`: Список словарей с данными о финансовых транзакциях.

### `process_bank_search(operations:list[dict], search:str)`

Функция, возвращающая список словарей, у которых в описании есть строка от пользователя.

*   **Параметры**

    *   `operations: list[dict]`: Список с транзакциями.

    *   `search: str`: Строка от пользователя.

*   **Возвращаемое значение**

    *   `list[dict]`: Список словарей сортированный по строке от пользователя.

*   **Пример:**
    
    ```python
    import re
    print(process_bank_search(transactions, "Перевод организации"))
    >>> [{'id': 939719570, 'state': 'EXECUTED', 'date': '2018-06-30T02:08:58.425572', 'operationAmount': {'amount': '9824.07', 'currency': {'name': 'USD', 'code': 'USD'}}, 'description': 'Перевод организации', 'from': 'Счет 75106830613657916952', 'to': 'Счет 11776614605963066702'},
         {'id': 594226727, 'state': 'CANCELED', 'date': '2018-09-12T21:27:25.241689', 'operationAmount': {'amount': '67314.70', 'currency': {'name': 'руб.', 'code': 'RUB'}}, 'description': 'Перевод организации', 'from': 'Visa Platinum 1246377376343588', 'to': 'Счет 14211924144426031657'}]
    
### `process_bank_counter(data:list[dict], categories:list)`

Функция, возвращающая словарь, в котором ключи — это названия категорий,
а значения — это количество операций в каждой категории.

*   **Параметры**

    *   `data: list[dict]`: Список с транзакциями.

    *   `categories: list`: Названия категорий.

*   **Возвращаемое значение**

    *   `dict`: Словарь, в котором ключи — это названия категорий, а значения — это количество операций в каждой категории.

*   **Пример:**
    
    ```python    
    import re
    from collections import Counter
    print(process_bank_search(transactions, "Перевод организации"))
    >>> [{'id': 939719570, 'state': 'EXECUTED', 'date': '2018-06-30T02:08:58.425572', 'operationAmount': {'amount': '9824.07', 'currency': {'name': 'USD', 'code': 'USD'}}, 'description': 'Перевод организации', 'from': 'Счет 75106830613657916952', 'to': 'Счет 11776614605963066702'},
         {'id': 594226727, 'state': 'CANCELED', 'date': '2018-09-12T21:27:25.241689', 'operationAmount': {'amount': '67314.70', 'currency': {'name': 'руб.', 'code': 'RUB'}}, 'description': 'Перевод организации', 'from': 'Visa Platinum 1246377376343588', 'to': 'Счет 14211924144426031657'}]
    
### 7. Модуль `external_api.py` содержит функции:

### `convert_currency(currency: str, amount: float)`

*   **Параметры:**
    *   currency (str): Транзакция.
    *   amount (float): Сумма, которую надо конвертировать.

*   **Возвращаемое значение:**
    *   `float:` Cумма транзакции.

*   **Пример:**

    ```python
    import os
    import requests
    from dotenv import load_dotenv
    print(convert_currency("USD", 100.0))
    >>> 7820.3993 # Эта сумма конвертирования валюты на 30.06.2025г. 
    
### `convert_to_rub(operation: dict)`

Функция конвертирования в рубли.

*   **Параметры**

    *   `operation: dict:` Словарь с данными о транзакции.

*   **Возвращаемое значение**

    *   `float:`  возвращает сумму транзакции (ключ amount) в рублях, тип данных float

*   **Пример:**

    ```python
    import os
    import requests
    from dotenv import load_dotenv
    print(convert_to_rub({
    "id": 27192367, "state": "CANCELED",
    "date": "2018-12-24T20:16:18.819037",
    "operationAmount": {"amount": "991.49",
    "currency": {"name": "руб.",
    "code": "RUB"}}}))
    >>> 991.49
    
### 8. Модуль `csv_excel.py` содержит функции:

### `read_csv_transactions(file_path: str)
`
Функция считывает финансовые операции (транзакции) из CSV-файла.

*   **Параметры**

    *   `file_path (str):` Путь до файла .csv (по умолчанию в этом проекте `'data/transactions.csv'`).

*   **Возвращаемое значение**

    *   `List[Dict]:`  Cписок словарей с данными о финансовых транзакциях   

*   **Пример:**

    ```python
    import csv
    from typing import Dict, List
    import pandas as pd
    print(read_csv_transactions("../data/transactions.csv"))

### `read_excel_transactions(file_path: str)
`
Функция считывает финансовые операции (транзакции) из EXCEL-файла.

*   **Параметры**

    *   `file_path (str):` Путь до файла .csv (по умолчанию в этом проекте `'data/transactions_excel.xlsx'`).

*   **Возвращаемое значение**

    *   `List[Dict]:`  Cписок словарей с данными о финансовых транзакциях

*   **Пример:**

    ```python
    import csv
    from typing import Dict, List
    import pandas as pd
    print(read_csv_transactions("../data/transactions_excel.xlsx"))

## Тестирование

Для обеспечения надежности и качества вашего кода, были разработаны тесты с использованием pytest.

### Установка библиотек и зависимостей, которые понадобятся для этого проекта:

#### Сделать:
`pip freeze > requirements.txt`
*   **pytest** - `pip install pytest`
*   **pytest-cov** - `pip install pytest-cov`
*   **pandas** - `poetry add pandas`
*   **requests** - `pip install requests`
*   **openpyxl** - `pip install openpyxl`
*   **coverage** - `pip install coverage`
#### линтеры
*   **black** - `pip install black`
*   **isort** - `pip install isort`
*   **flake8** - `pip install flake8`
*   **mypy** - `pip install mypy`

### Запуск тестов

1. Перейдите в каталог с вашим проектом в терминале.
2. Запустите все тесты, выполнив команду: `pytest`
3. Генерация отчетов о покрытии:

* `-v`: (verbose) - отображает подробную информацию о прохождении тестов.
* `--cov=your_module`: Указывает `pytest-cov` анализировать покрытие кода для вашего модуля.

   Заменив `your_module` на имя вашего модуля Python (без расширения `.py`).
* `--cov-report=term-missing`: Отображает строки кода, которые не были покрыты тестами.
* `--cov=src --cov-report=html`: Создаёт файл HTMLCOV в корне проекта со всеми параметрами тестов.

### Анализ результатов

1. `Pytest` покажет результаты тестирования, указывая количество пройденных, пропущенных и упавших тестов.
2. `Pytest-cov` предоставит отчет о покрытии кода, показывая процент покрытия каждой функции и информацию
о строках, которые не были покрыты тестами.
3. Анализируйте результаты тестов и отчет о покрытии кода. Если какие-либо строки кода не покрыты,
рассмотрите возможность добавления новых тестов или корректировки существующих для улучшения покрытия.

## Документация

Более подробную документацию по каждой функции можно найти в `docstrings` внутри исходного кода.

## Лицензия

Сведения о лицензии проекта (например, MIT, Apache 2.0) [укажите здесь](https://github.com).

## Контакты

Укажите [ваши контактные данные](https://github.com) или
[способы связи](https://github.com) для обратной связи и поддержки.

